##### 题目

找到整数数组nums中找到和为目标值target的两个数，返回该二元组索引；

- 假设仅存在一个二元组的和等于target；



##### 解答

- 哈希表法；

- 遍历数组，利用哈希表的快速查找，在表中找当前元素的互补值，没找到就把该元素存入表中并继续遍历；
- unodered_map简述：<key, value>，其中key参与hash，是索引；value只是与key绑定的业务数据；
- 注意key存元素值，value才存索引，因为find只能传入key；

~~~cpp
vector<int> twoSum(vector<int>& nums, int target)
{
    int n = nums.size();
    unordered_map<int, int>map; 
    
    for(int i = 0;i < n;i++)
    {
		if(const auto it = map.find(target - nums[i]);it != map.end())
            return {i, it->second};
        map[nums[i]] = i;
    }
    return {};
}
~~~

> 也可用双指针法：先对数组排序，然后左指针指向数组首，右指针指向数组尾，和大于target右指针左移，小于左指针右移；
>
> 但是排序会打乱数组，不好返回原始索引，必须用vector<pair<int, int>>去保存原始 值-索引 映射；如果不要求返回索引直接返回值就没有这么麻烦；



